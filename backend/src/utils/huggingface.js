import { createCanvas } from 'canvas';

export const generateResumeFromJobDescription = async (userData) => {
  try {
    const canvasImage = await generateResumeImageCanvas(userData);
    return {
      success: true,
      type: 'image',
      imageData: canvasImage.dataUrl,
      buffer: canvasImage.buffer,
      model: 'Canvas Generator',
      format: 'png',
    };
  } catch (error) {
    console.error('Canvas generation error:', error);
    throw new Error('Canvas generation failed');
  }
};

const generateResumeImageCanvas = async (userData) => {
  const width = 800;
  const height = 1100;
  const canvas = createCanvas(width, height);
  const ctx = canvas.getContext('2d');

  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, width, height);

  // Header
  ctx.fillStyle = '#2c3e50';
  ctx.fillRect(0, 0, width, 130);
  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 32px Arial';
  ctx.textAlign = 'center';
  ctx.fillText(userData.name || 'John Doe', width / 2, 55);
  ctx.font = '16px Arial';
  ctx.fillText(
    `${userData.email || 'email@example.com'} | ${userData.phone || '+91-9876543210'}`,
    width / 2,
    90
  );

  let y = 160;
  const margin = 60;

  // Utility: Add Section
  const addSection = (title) => {
    ctx.fillStyle = '#2c3e50';
    ctx.font = 'bold 20px Arial';
    ctx.textAlign = 'left';
    ctx.fillText(title, margin, y);
    ctx.strokeStyle = '#3498db';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(margin, y + 8);
    ctx.lineTo(margin + 180, y + 8);
    ctx.stroke();
    y += 30;
  };

  // Utility: Add Paragraph
  const addTextBlock = (text, maxWidth = width - 2 * margin) => {
    ctx.fillStyle = '#495057';
    ctx.font = '14px Arial';
    const lines = wrapText(ctx, text, maxWidth);
    lines.forEach((line) => {
      ctx.fillText(line, margin, y);
      y += 20;
    });
    y += 10;
  };

  // Utility: Add Bullets
  const addBullets = (items) => {
    items.forEach((item) => {
      ctx.beginPath();
      ctx.arc(margin + 5, y - 5, 3, 0, 2 * Math.PI);
      ctx.fillStyle = '#3498db';
      ctx.fill();
      ctx.fillStyle = '#495057';
      ctx.font = '14px Arial';
      ctx.fillText(item, margin + 15, y);
      y += 22;
    });
    y += 5;
  };

  // Extract Object Values Utility
  const extractText = (input, keys = []) => {
    if (typeof input === 'string') return input;
    if (Array.isArray(input)) {
      return input.map(i => extractText(i, keys)).join('; ');
    }
    if (typeof input === 'object' && input !== null) {
      return keys.map(k => input[k]).filter(Boolean).join(', ') || JSON.stringify(input);
    }
    return String(input);
  };

  // Sections
  if (userData.prompt) {
    addSection('Professional Summary');
    addTextBlock(userData.prompt);
  }

  if (userData.education) {
    addSection('Education');
    const edu = extractText(userData.education, ['degree', 'institution', 'school', 'field']);
    addTextBlock(edu);
  }

  if (userData.experience) {
    addSection('Experience');
    const exp = extractText(userData.experience, ['position', 'company', 'description']);
    addTextBlock(exp);
  }

  if (userData.skills && userData.skills.length) {
    addSection('Skills');
    const skills = userData.skills.slice(0, 10).map(skill =>
      extractText(skill, ['name', 'skill', 'title'])
    );
    addBullets(skills);
  }

  if (userData.projects && userData.projects.length) {
    addSection('Projects');
    const projects = userData.projects.slice(0, 5).map(p =>
      extractText(p, ['name', 'title', 'description'])
    );
    addBullets(projects);
  }

  if (userData.certifications && userData.certifications.length) {
    addSection('Certifications');
    const certs = userData.certifications.slice(0, 4).map(cert =>
      extractText(cert, ['name', 'title', 'certification', 'course'])
    );
    addBullets(certs);
  }

  // Footer
  ctx.fillStyle = '#adb5bd';
  ctx.font = '10px Arial';
  ctx.textAlign = 'center';
  ctx.fillText('Generated by ElevateCV AI', width / 2, height - 20);

  const buffer = canvas.toBuffer('image/png');
  const base64Image = buffer.toString('base64');
  const dataUrl = `data:image/png;base64,${base64Image}`;
  return { dataUrl, buffer };
};

// Word Wrap Helper
const wrapText = (ctx, text, maxWidth) => {
  const words = text.split(' ');
  const lines = [];
  let line = words[0];
  for (let i = 1; i < words.length; i++) {
    const testLine = line + ' ' + words[i];
    if (ctx.measureText(testLine).width < maxWidth) {
      line = testLine;
    } else {
      lines.push(line);
      line = words[i];
    }
  }
  lines.push(line);
  return lines;
};